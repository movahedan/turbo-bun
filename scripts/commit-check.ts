#!/usr/bin/env bun

import { $ } from "bun";
import { EntityCommit, validBranchPrefixes } from "./entities";
import { colorify } from "./shell/colorify";
import { createScript, validators } from "./shell/create-scripts";

const scriptConfig = {
	name: "Commit Check",
	description:
		"Comprehensive commit validation with step-based checking. Supports message strings, files, branch validation, and staged file checks.",
	usage: "bun run commit-check [options]",
	examples: [
		"bun run commit-check",
		"bun run commit-check --message 'feat: add new feature'",
		"bun run commit-check --message-file .git/COMMIT_EDITMSG",
		"bun run commit-check --branch",
		"bun run commit-check --staged",
		"bun run commit-check --message 'fix: resolve bug' --branch --staged",
	],
	options: [
		{
			short: "-m",
			long: "--message",
			description: "Validate specific commit message string",
			required: false,
			validator: validators.nonEmpty,
		},
		{
			short: "-f",
			long: "--message-file",
			description: "Read and validate message from file",
			required: false,
			validator: validators.fileExists,
		},
		{
			short: "-b",
			long: "--branch",
			description: "Validate current branch name",
			required: false,
			defaultValue: false,
			validator: validators.boolean,
		},
		{
			short: "-s",
			long: "--staged",
			description: "Validate staged files for policy violations",
			required: false,
			defaultValue: false,
			validator: validators.boolean,
		},
	],
} as const;

export const commitCheck = createScript(scriptConfig, async (args, xConsole) => {
	if (args["message-file"] || args.message) {
		xConsole.log(colorify.blue("üîç Validating commit message from file..."));
		const commitMessage = args["message-file"]
			? await Bun.file(args["message-file"]).text()
			: args.message;
		if (!commitMessage) {
			xConsole.error(colorify.red("‚ùå No commit message found"));
			throw new Error("No commit message found");
		}

		const validation = await EntityCommit.validateCommitMessage(commitMessage);
		if (validation.length > 0) {
			xConsole.error(colorify.red("‚ùå Commit message validation failed:"));
			for (const error of validation) {
				xConsole.error(colorify.red(`  ‚Ä¢ ${error}`));
			}
			throw new Error("Commit message validation failed");
		}
	}

	if (args.branch) {
		try {
			xConsole.log(colorify.blue("üîç Running branch name validation..."));
			await checkBranchName();
		} catch (error) {
			xConsole.error(colorify.red("‚ùå Branch name validation failed:"));
			xConsole.error(colorify.red(`  ‚Ä¢ ${error instanceof Error ? error.message : String(error)}`));
			throw new Error("Branch name validation failed");
		}
	}

	if (args.staged) {
		try {
			xConsole.log(colorify.blue("üîç Running staged files validation..."));
			await checkStagedFiles();
		} catch (error) {
			xConsole.error(colorify.red("‚ùå Staged files validation failed:"));
			xConsole.error(colorify.red(`  ‚Ä¢ ${error instanceof Error ? error.message : String(error)}`));
			throw new Error("Staged files validation failed");
		}
	}
});

if (import.meta.main) {
	commitCheck();
}

async function checkStagedFiles(): Promise<boolean> {
	console.log(colorify.blue("üìÅ Checking staged files for policy violations..."));

	const issuePatterns = [
		{
			filePattern: [
				/\.vscode\/.*/,
				/coverage\/.*/,
				/dist\/.*/,
				/node_modules\/.*/,
				/\.env/,
				/\.act/,
			],
			description: "development files should not be manually committed",
		},
		{
			filePattern: [/CHANGELOG.md/],
			contentPattern: [
				/^# @repo\/[^/]+$/m, // Manual package name headers
				/^## \[[^\]]+\] - \d{4}-\d{2}-\d{2}$/m, // Manual version headers
				/^- [^-]/m, // Manual bullet points that don't start with "- -"
			],
			description: "CHANGELOG.md should be auto-generated by 'bun run version:commit'",
		},
		{
			filePattern: [/package.json/],
			contentPattern: [
				/^[+-]\s*"version":\s*"[^"]+"/, // Manual version changes
			],
			ignore: { mode: "create" },
			description: "package.json version should be auto-generated by 'bun run version:commit'",
		},
	];

	async function findIssues(filePath: string): Promise<string[]> {
		const issues: string[] = [];

		for (const pattern of issuePatterns) {
			const fileNameMatches = pattern.filePattern.some((p) => p.test(filePath));
			if (!fileNameMatches) continue;

			const stagedDiff = await $`git diff --cached -- ${filePath}`.text();
			const contentMatches = pattern.contentPattern?.some((p) => p.test(stagedDiff)) ?? true;

			// Check if this is a new file and should be ignored
			const isNewFile =
				stagedDiff.includes("new file mode") || stagedDiff.includes("--- /dev/null");
			const shouldIgnore = pattern.ignore?.mode === "create" && isNewFile;

			if (contentMatches && !shouldIgnore) {
				issues.push(`${filePath}: ${pattern.description}`);
			}
		}

		return issues;
	}

	async function checkGitStatus(): Promise<{ stagedFiles: string[] }> {
		const status = await $`git status --porcelain`.text();
		const lines = status.split("\n").filter(Boolean);

		return {
			stagedFiles: lines
				.filter((line) => line.startsWith("A ") || line.startsWith("M "))
				.map((line) => line.substring(3)),
		};
	}

	try {
		const { stagedFiles } = await checkGitStatus();

		if (!stagedFiles.length) {
			console.log(colorify.green("‚úÖ No staged changes"));
			return true;
		}

		console.log(
			colorify.gray(`Found ${stagedFiles.length} staged files: ${stagedFiles.join(", ")}`),
		);

		const allIssues = await Promise.all(
			stagedFiles.map(async (file) => await findIssues(file)),
		).then((issues) => issues.flat());

		if (allIssues.length === 0) {
			console.log(colorify.green("‚úÖ No policy violations found in staged files"));
			return true;
		}

		console.error(colorify.red("‚ùå Policy violations found:"));
		for (const issue of allIssues) {
			console.error(colorify.red(`  ‚Ä¢ ${issue}`));
		}

		console.error(colorify.yellow("\nüí° To fix these issues:"));
		console.error(
			colorify.yellow("  ‚Ä¢ Use 'bun run version:commit' for version and changelog updates"),
		);
		console.error(colorify.yellow("  ‚Ä¢ Avoid committing development files manually"));
		console.error(
			colorify.yellow("  ‚Ä¢ Let automation handle package.json and CHANGELOG.md updates"),
		);

		return false;
	} catch (error) {
		console.error(colorify.red("‚ùå Failed to check staged files:"));
		console.error(colorify.red(`  ‚Ä¢ ${error instanceof Error ? error.message : String(error)}`));
		return false;
	}
}

async function checkBranchName(): Promise<boolean> {
	const isCI = process.env.CI === "true" || process.env.GITHUB_ACTIONS === "true";
	const { stdout: currentBranch } = await $`git branch --show-current`;

	const branchName =
		process.env.GITHUB_HEAD_REF ||
		process.env.GITHUB_REF?.replace("refs/heads/", "") ||
		currentBranch.toString().trim() ||
		"";

	const patterns = validBranchPrefixes.reduce(
		(acc, prefix) => {
			acc[prefix] = new RegExp(`^${prefix}/([a-z0-9.-]+)$`);
			return acc;
		},
		{} as Record<(typeof validBranchPrefixes)[number], RegExp>,
	);

	const isValidBranchName = (name: string): boolean => {
		if (name === "main") {
			return true;
		}

		console.log(colorify.blue(`üîç Checking branch name: ${name}`));
		return Object.values(patterns).some((pattern) => pattern.test(name));
	};

	// Skip branch name check in CI if we don't have a valid branch name
	if (isCI && !isValidBranchName(branchName)) {
		console.log(colorify.yellow("‚ö†Ô∏è  Skipping branch name check in CI environment"));
		console.log(colorify.gray(`Branch name detected: ${branchName}`));
		return true;
	}

	if (isValidBranchName(branchName)) {
		console.log(colorify.green("‚úÖ Branch name validation passed"));
		return true;
	}

	console.error(colorify.red("‚ùå Invalid branch name!"));
	console.error(colorify.red("\nBranch name should follow one of these patterns:"));
	for (const prefix of validBranchPrefixes) {
		if (prefix === "release") {
			console.error(colorify.gray(`  - ${prefix}/1.0.0`));
		} else {
			console.error(colorify.gray(`  - ${prefix}/your-${prefix}-name`));
		}
	}
	return false;
}
